{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Nano isn't production-ready yet, it's in an early stage of development, you can always create an issue for suggestions An application architecture pattern than a framework for Flutter utilizing a unidirectional data flow. The goal of Nano is to make it easy to separate the business logic from the presentation layer, with modular state management to allow developers to build smaller parts, that can be tested in isolation. Nano is highly focused on architectural pattern and code structure that's scalable and modular to increase code re-usability with less to no refactoring. Nano is heavily inspired by existing solutions like Redux, BLoC pattern and Flux. Internally Nano has nothing out of ordinary for state management, it's just streams on top of rxdart and some helper functions to make your life easier. Nano's unidirectional data flow diagram Store Contains the application state It has computed values as getters and helper functions Store takse a Mutation Type which act as an input for the reducer Events are emitted as Streams State can't be changed directly from outside //Accepted mutation by this store enum CounterMutation { increment , decrement , error , } class CounterState extends StateManager < int , CounterMutation > { //initial state as 0 CounterState () : super ( 0 ); } Reducer Pure function simillar to Redux Receive Mutation as input and update the state as output Same mutations will always generate same results class CounterState extends StateManager < int , CounterMutation > { CounterState () : super ( 0 ); @override void reducer ( mutation ){ switch ( mutation ) { case CounterActions . increment: updateState ( cData + 1 ); break ; case CounterActions . decrement: updateState ( cData - 1 ); break ; case CounterActions . error: updateStateWithError ( \"Invalid action\" ); break ; default : throw Exception ( \"Invalid action\" ); } } } Action Actions cause change in the state Actions contains set of mutations, which are called once the action has been completed. Actions has full aschronous support All the API calls are performed in the actions body //without any body final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); //with body final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); Dispatcher Dispatcher is a singleton where all the actions go through Dispatcher doesn't registers store refernces The actions provided contains mutation with reference to the store and mutation type Dispatcher manages order of Actions execution // There are multiple ways to dipatch actions depending upon the // situation but this is what will be used most of times final counter = CounterStore (); //sync await setRef ( CounterParam ( counter , 5 , 200 )). run (); //async setRef ( CounterParam ( counter , 5 , 200 )). run ();","title":"Introduction"},{"location":"#introduction","text":"Nano isn't production-ready yet, it's in an early stage of development, you can always create an issue for suggestions An application architecture pattern than a framework for Flutter utilizing a unidirectional data flow. The goal of Nano is to make it easy to separate the business logic from the presentation layer, with modular state management to allow developers to build smaller parts, that can be tested in isolation. Nano is highly focused on architectural pattern and code structure that's scalable and modular to increase code re-usability with less to no refactoring. Nano is heavily inspired by existing solutions like Redux, BLoC pattern and Flux. Internally Nano has nothing out of ordinary for state management, it's just streams on top of rxdart and some helper functions to make your life easier. Nano's unidirectional data flow diagram Store Contains the application state It has computed values as getters and helper functions Store takse a Mutation Type which act as an input for the reducer Events are emitted as Streams State can't be changed directly from outside //Accepted mutation by this store enum CounterMutation { increment , decrement , error , } class CounterState extends StateManager < int , CounterMutation > { //initial state as 0 CounterState () : super ( 0 ); } Reducer Pure function simillar to Redux Receive Mutation as input and update the state as output Same mutations will always generate same results class CounterState extends StateManager < int , CounterMutation > { CounterState () : super ( 0 ); @override void reducer ( mutation ){ switch ( mutation ) { case CounterActions . increment: updateState ( cData + 1 ); break ; case CounterActions . decrement: updateState ( cData - 1 ); break ; case CounterActions . error: updateStateWithError ( \"Invalid action\" ); break ; default : throw Exception ( \"Invalid action\" ); } } } Action Actions cause change in the state Actions contains set of mutations, which are called once the action has been completed. Actions has full aschronous support All the API calls are performed in the actions body //without any body final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); //with body final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); Dispatcher Dispatcher is a singleton where all the actions go through Dispatcher doesn't registers store refernces The actions provided contains mutation with reference to the store and mutation type Dispatcher manages order of Actions execution // There are multiple ways to dipatch actions depending upon the // situation but this is what will be used most of times final counter = CounterStore (); //sync await setRef ( CounterParam ( counter , 5 , 200 )). run (); //async setRef ( CounterParam ( counter , 5 , 200 )). run ();","title":"Introduction"},{"location":"quickstart/","text":"Quickstart \u00b6 Here we will try to create a simple Counter app. I will be writing more tutorial about some large which will help you understand the goal of this library a lot better. Creating a store \u00b6 We need to create a Store to keep our counts track and to update the listeners automatically on every change. To create a store we need to extend our class with Store provided from the nano package class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); } What is int and CounterMutations? The first type of the Store is the type of our state that we are going to emit. Here we are going to emit integers so it's int incase of a string it will be String this will prevent you from emiting anything other than the state defined The second type of the Store is the type of mutations. Every store responds to specific mutations, if correct mutation is received it will be send to the reducer to modify the state. We are going to define CounterMutations in next step. We have now defined our store and the argument passed to super() is the inital state. If we don't pass any argument the inital state will not be set and all the listeners will receive a waiting state which basically means that the Store hasn't emitted any events yet. Define Mutations \u00b6 Mutations are specific event which our store recognizes and responds to it. Here I'm defining class based mutations, it isn't necessary to use class based mutations simple can enums can also be use but when we want some inputs with our mutations it's better to use class based mutations as you can take the benefit of linting with static typing. abstract class CounterMutations {} class IncrementMutation extends CounterMutations {} class DecrementMutation extends CounterMutations {} class ErrorMutation extends CounterMutations {} class CountMutation extends CounterMutations { final int count ; CountMutation ( this . count ); } Now I can't send any mutations other than IncrementMutation , DecrementMutation , ErrorMutation and CountMutation . Defining Reducer \u00b6 In nano every store has it's own reducer. Reducer sole job is to respond to the mutations received. Now we will override the reducer from Store in our CounterStore class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); @override void reducer ( mutation ) { if ( mutation is IncrementMutation ) updateState ( cData + 1 ); if ( mutation is DecrementMutation ) updateState ( cData - 1 ); if ( mutation is ErrorMutation ) updateStateWithError ( \"Invalid mutation\" ); if ( mutation is CountMutation ) updateState ( mutation . count ); } } The Store provides you two functions updateState() and updateStateWithError() which update the state and all the listners receive the latest copy of the state. When updateState is called the listeners receive a data event and the onData callback is called. When updateStateWithError is called the listeners receive an error event and the onErro callback is called. Please call updateState in reducer() only Don't create any other function or directly try to mutate the state. The way abstraction works in Dart the two functions for updating state updateState and updateStateWithError couldn't be hidden outside the class defination but please only call it in your reducer. Defining Actions \u00b6 Mutations can't be send directly to the store they are sent through Actions but since Actions also plays a major role like making async calls and once Action can cause mutation to multiple stores, when we say Actions causes change we don't strictly imply that. Actions carry the mutations and actions are added to the Dispatcher. The dispatcher waits for the Actions to complete and then it sends to the mutation to the respective stores. We will create action references and whenever we need to create an action we will call the refernce. References can be global as they are immutable but it's better you create them as static members inside a class First we will create a file actions.dart in our lib folder. Then paste the following code in the file //Actions final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); final decrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , DecrementMutation ())], ); final errortRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , ErrorMutation ())], ); final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); ActionRef has few important parameters body Optional parameter Perform all async operations here like API calls fetching from data base returns a List<Mutation(store,type)> mutations Required paramter Takes 2 paramter result the returned value of body() and payload for dependcy injection Creating our widget \u00b6 class CounterApp extends StatefulWidget { CounterApp ({ Key key }) : super ( key: key ); @override _CounterAppState createState () => _CounterAppState (); } class _CounterAppState extends State < CounterApp > { final _counter = CounterState (); void handleIncrement () => incrementRef ( _counter ). run (); void handleDecrement () => decrementRef ( _counter ). run (); void handleError () => errorRef ( _counter ). run (); void handleCount () => setRef ( CounterParam ( _counter , 5 )). run (); @override Widget build ( BuildContext context ) { return Scaffold ( appBar: AppBar ( title: Text ( \"Counter\" )), body: StateBuilder < int > ( initialState: _counter . state , stream: _counter . stream , rebuildOnly: ( state ) => (( state . data ?? 1 ) % 2 == 0 ), builder: ( context , state , init ) => Center ( child: Text ( state . toString ())), ), floatingActionButton: Column ( mainAxisAlignment: MainAxisAlignment . end , children: < Widget > [ FloatingActionButton ( mini: true , heroTag: null , onPressed: handleIncrement , child: Icon ( Icons . add ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleDecrement , child: Icon ( Icons . remove ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleError , child: Icon ( Icons . close ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleCount , child: Icon ( Icons . plus_one ), ), ], ), ); } } The StateBuilder widget takes the Store and listens for event. It might look very raw as because the depency inject is very loosely coupled so anyone can use their favourite depency injection library. Creating views \u00b6 Views are the integrating point this is where we build our widget tree and integrate everything. Create a file name views.dart and paste the following code. class App extends StatelessWidget { const App ({ Key key }) : super ( key: key ); @override Widget build ( BuildContext context ) { return MaterialApp ( home: CounterApp ()); } }","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Here we will try to create a simple Counter app. I will be writing more tutorial about some large which will help you understand the goal of this library a lot better.","title":"Quickstart"},{"location":"quickstart/#creating-a-store","text":"We need to create a Store to keep our counts track and to update the listeners automatically on every change. To create a store we need to extend our class with Store provided from the nano package class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); } What is int and CounterMutations? The first type of the Store is the type of our state that we are going to emit. Here we are going to emit integers so it's int incase of a string it will be String this will prevent you from emiting anything other than the state defined The second type of the Store is the type of mutations. Every store responds to specific mutations, if correct mutation is received it will be send to the reducer to modify the state. We are going to define CounterMutations in next step. We have now defined our store and the argument passed to super() is the inital state. If we don't pass any argument the inital state will not be set and all the listeners will receive a waiting state which basically means that the Store hasn't emitted any events yet.","title":"Creating a store"},{"location":"quickstart/#define-mutations","text":"Mutations are specific event which our store recognizes and responds to it. Here I'm defining class based mutations, it isn't necessary to use class based mutations simple can enums can also be use but when we want some inputs with our mutations it's better to use class based mutations as you can take the benefit of linting with static typing. abstract class CounterMutations {} class IncrementMutation extends CounterMutations {} class DecrementMutation extends CounterMutations {} class ErrorMutation extends CounterMutations {} class CountMutation extends CounterMutations { final int count ; CountMutation ( this . count ); } Now I can't send any mutations other than IncrementMutation , DecrementMutation , ErrorMutation and CountMutation .","title":"Define Mutations"},{"location":"quickstart/#defining-reducer","text":"In nano every store has it's own reducer. Reducer sole job is to respond to the mutations received. Now we will override the reducer from Store in our CounterStore class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); @override void reducer ( mutation ) { if ( mutation is IncrementMutation ) updateState ( cData + 1 ); if ( mutation is DecrementMutation ) updateState ( cData - 1 ); if ( mutation is ErrorMutation ) updateStateWithError ( \"Invalid mutation\" ); if ( mutation is CountMutation ) updateState ( mutation . count ); } } The Store provides you two functions updateState() and updateStateWithError() which update the state and all the listners receive the latest copy of the state. When updateState is called the listeners receive a data event and the onData callback is called. When updateStateWithError is called the listeners receive an error event and the onErro callback is called. Please call updateState in reducer() only Don't create any other function or directly try to mutate the state. The way abstraction works in Dart the two functions for updating state updateState and updateStateWithError couldn't be hidden outside the class defination but please only call it in your reducer.","title":"Defining Reducer"},{"location":"quickstart/#defining-actions","text":"Mutations can't be send directly to the store they are sent through Actions but since Actions also plays a major role like making async calls and once Action can cause mutation to multiple stores, when we say Actions causes change we don't strictly imply that. Actions carry the mutations and actions are added to the Dispatcher. The dispatcher waits for the Actions to complete and then it sends to the mutation to the respective stores. We will create action references and whenever we need to create an action we will call the refernce. References can be global as they are immutable but it's better you create them as static members inside a class First we will create a file actions.dart in our lib folder. Then paste the following code in the file //Actions final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); final decrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , DecrementMutation ())], ); final errortRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , ErrorMutation ())], ); final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); ActionRef has few important parameters body Optional parameter Perform all async operations here like API calls fetching from data base returns a List<Mutation(store,type)> mutations Required paramter Takes 2 paramter result the returned value of body() and payload for dependcy injection","title":"Defining Actions"},{"location":"quickstart/#creating-our-widget","text":"class CounterApp extends StatefulWidget { CounterApp ({ Key key }) : super ( key: key ); @override _CounterAppState createState () => _CounterAppState (); } class _CounterAppState extends State < CounterApp > { final _counter = CounterState (); void handleIncrement () => incrementRef ( _counter ). run (); void handleDecrement () => decrementRef ( _counter ). run (); void handleError () => errorRef ( _counter ). run (); void handleCount () => setRef ( CounterParam ( _counter , 5 )). run (); @override Widget build ( BuildContext context ) { return Scaffold ( appBar: AppBar ( title: Text ( \"Counter\" )), body: StateBuilder < int > ( initialState: _counter . state , stream: _counter . stream , rebuildOnly: ( state ) => (( state . data ?? 1 ) % 2 == 0 ), builder: ( context , state , init ) => Center ( child: Text ( state . toString ())), ), floatingActionButton: Column ( mainAxisAlignment: MainAxisAlignment . end , children: < Widget > [ FloatingActionButton ( mini: true , heroTag: null , onPressed: handleIncrement , child: Icon ( Icons . add ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleDecrement , child: Icon ( Icons . remove ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleError , child: Icon ( Icons . close ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleCount , child: Icon ( Icons . plus_one ), ), ], ), ); } } The StateBuilder widget takes the Store and listens for event. It might look very raw as because the depency inject is very loosely coupled so anyone can use their favourite depency injection library.","title":"Creating our widget"},{"location":"quickstart/#creating-views","text":"Views are the integrating point this is where we build our widget tree and integrate everything. Create a file name views.dart and paste the following code. class App extends StatelessWidget { const App ({ Key key }) : super ( key: key ); @override Widget build ( BuildContext context ) { return MaterialApp ( home: CounterApp ()); } }","title":"Creating views"},{"location":"API%20Documentation/","text":"Getting Started \u00b6","title":"Getting Started"},{"location":"API%20Documentation/#getting-started","text":"","title":"Getting Started"},{"location":"API%20Documentation/about/","text":"Getting started \u00b6 Installation \u00b6 While there are several ways of installing Material for MkDocs, the recommended methods are either by using pip \u2013 the Python package manager \u2013 or by pulling the official Docker image . with pip recommended \u00b6 Material for MkDocs can be installed with pip : pip install mkdocs-material Note that this will automatically install compatible versions of MkDocs , Markdown , Pygments and PyMdown Extensions . Material for MkDocs always strives to support the latest versions, so there's no need to install those packages separately. Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a tutorial on virtual environments for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Installing in user space (recommended): Provide the --user flag to the install command and pip will install the package in a user-site location. This is the recommended way. Switching to a homebrewed Python : Upgrade your Python installation to a self-contained solution by installing Python with Homebrew. This should eliminate a lot of problems you could be having with pip . Error: unrecognized theme 'material' If you run into this error, the most common reason is that you installed MkDocs through some package manager (e.g. Homebrew or apt-get ) and Material for MkDocs through pip , so both packages end up in different locations. MkDocs only checks its install location for themes. with docker recommended \u00b6 The official Docker image is a great way to get up and running in a few minutes, as it comes with all dependencies pre-installed. Pull the image for the latest version with: docker pull squidfunk/mkdocs-material The mkdocs executable is provided as an entry point and serve is the default command. Start the development server in your project root \u2013 the folder where mkdocs.yml resides \u2014 with: Unix docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material Windows docker run --rm -it -p 8000:8000 -v \"%cd%\":/docs squidfunk/mkdocs-material with git \u00b6 Material for MkDocs can be directly used from GitHub by cloning the repository into a subfolder of your project root which might be useful if you want to use the very latest version: git clone https://github.com/squidfunk/mkdocs-material.git The theme will reside in the folder mkdocs-material/material . Configuration \u00b6 Depending on your installation method, you can now add the following lines to mkdocs.yml in your project root. If you installed Material for MkDocs using a package manager, add: theme : name : material If you cloned Material for MkDocs from GitHub add: theme : name : null custom_dir : mkdocs-material/material MkDocs includes a development server, so you can preview your changes as you write your documentation. The development server can be started with the following command: mkdocs serve Point your browser to http://localhost:8000 and your documentation should greet you in a new look. If you're starting from scratch, the following configuration can be used as a starting point: Example configuration This is an excerpt from the mkdocs.yml used to render these pages: # Project information site_name : Material for MkDocs site_description : A Material Design theme for MkDocs site_author : Martin Donath site_url : https://squidfunk.github.io/mkdocs-material/ # Repository repo_name : squidfunk/mkdocs-material repo_url : https://github.com/squidfunk/mkdocs-material # Copyright copyright : Copyright &copy; 2016 - 2020 Martin Donath # Configuration theme : name : material language : en palette : primary : indigo accent : indigo font : text : Roboto code : Roboto Mono # Extras extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/squidfunk - icon : fontawesome/brands/twitter link : https://twitter.com/squidfunk - icon : fontawesome/brands/linkedin link : https://linkedin.com/in/squidfunk # Google Analytics google_analytics : - UA-XXXXXXXX-X - auto # Extensions markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true Feature flags \u00b6 These optional features are hidden behind flags and can be explicitly enabled in mkdocs.yml . Instant loading \u00b6 The (still experimental) instant loading feature will intercept clicks on all internal links and dispatch them directly via XHR without a full page reload. It can be enabled from mkdocs.yml with: theme : features : - instant The resulting page is parsed and injected and all event handlers and components are automatically rebound. This means that Material for MkDocs behaves like a Single Page Application , which is especially useful for large documentation sites that come with a huge search index, as the search index will now remain intact in-between document switches. Tabs \u00b6 The tabs feature will render top-level subsections in another navigational layer below the header on big screens (but leave them untouched on mobile). It can be enabled from mkdocs.yml with: theme : features : - tabs Note that all top-level pages (i.e. all top-level entries that directly refer to an *.md file) defined inside the nav entry of mkdocs.yml will be grouped under the first tab which will receive the title of the first page. This means that there will effectively be no collapsible subsections for the first tab, as each subsection is rendered as another tab. If you want more fine-grained control, i.e., collapsible subsections for the first tab, you can move all top-level pages into a subsection , so that the top-level is entirely made up of subsections. Note that tabs are only shown for larger screens, so make sure that navigation is plausible on mobile devices. As an example, see the mkdocs.yml used to render these pages. Language \u00b6 Default: en Material for MkDocs supports internationalization (i18n) and provides translations for all template variables and labels. You can set the language from mkdocs.yml with: theme : language : en The following language codes are supported: .md-language-list { -webkit-columns: 2; -moz-columns: 2; columns: 2; } .md-language-list li { -webkit-column-break-inside: avoid; page-break-inside: avoid; break-inside: avoid; } af / Afrikaans ar / Arabic bn / Bengali (Bangla) ca / Catalan cs / Czech da / Danish de / German en / English es / Spanish et / Estonian fa / Persian (Farsi) fi / Finnish fr / French gl / Galician gr / Greek he / Hebrew hi / Hindi hr / Croatian hu / Hungarian id / Indonesian it / Italian ja / Japanese kr / Korean my / Burmese nl / Dutch nn / Norwegian (Nynorsk) no / Norwegian pl / Polish pt / Portuguese ro / Romanian ru / Russian sh / Serbo-Croatian si / Slovenian sk / Slovak sr / Serbian sv / Swedish th / Thai tr / Turkish uk / Ukrainian vi / Vietnamese zh / Chinese (Simplified) zh-Hant / Chinese (Traditional) zh-TW / Chinese (Taiwanese) Add language While many languages are read ltr (left-to-right), Material for MkDocs also supports rtl (right-to-left) directionality which is inferred from the selected language, but can also be set with: theme : direction : rtl Color scheme \u00b6 Default: default Material for MkDocs supports two color schemes: a light mode, which is just called default , and a dark mode, which is called slate . The color scheme can be set from mkdocs.yml : theme : palette : scheme : slate Click on a color name to change the color scheme of the theme: .md-typeset button[data-md-color-scheme] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-scheme]:hover { opacity: 0.75; } .md-typeset button[data-md-color-scheme] > code { display: block; color: var(--md-primary-bg-color); background-color: var(--md-primary-fg-color); } default slate var buttons = document.querySelectorAll(\"button[data-md-color-scheme]\") buttons.forEach(function(button) { var attr = \"data-md-color-scheme\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) }) The color scheme can also be set based on user preference , which makes use of the prefers-color-scheme media query. This can be done by adding the following to mkdocs.yml : theme : palette : scheme : preference Color palette \u00b6 The Material Design color palette comes with 20 hues, all of which are included with Material for MkDocs. Primary and accent colors can be set from the project root's mkdocs.yml : theme : palette : primary : indigo accent : indigo If the colors are set with these configuration options, an additional CSS file that includes the hues of the color palette is automatically included and linked from the template. Custom colors with CSS variables Material for MkDocs defines all colors as CSS variables. If you want to customize the colors beyond the palette (e.g. to use your brand's colors), you can add an additional stylesheet and override the defaults: : root { /* Default color shades */ -- md-default-fg-color : ... ; -- md-default-fg-color--light : ... ; -- md-default-fg-color--lighter : ... ; -- md-default-fg-color--lightest : ... ; -- md-default-bg-color : ... ; -- md-default-bg-color--light : ... ; -- md-default-bg-color--lighter : ... ; -- md-default-bg-color--lightest : ... ; /* Primary color shades */ -- md-primary-fg-color : ... ; -- md-primary-fg-color--light : ... ; -- md-primary-fg-color--dark : ... ; -- md-primary-bg-color : ... ; -- md-primary-bg-color--light : ... ; /* Accent color shades */ -- md-accent-fg-color : ... ; -- md-accent-fg-color--transparent : ... ; -- md-accent-bg-color : ... ; -- md-accent-bg-color--light : ... ; } : root > * { /* Code block color shades */ -- md-code-bg-color : ... ; -- md-code-fg-color : ... ; } Primary color \u00b6 Default: indigo Click on a color name to change the primary color of the theme: .md-typeset button[data-md-color-primary] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-primary]:hover { opacity: 0.75; } .md-typeset button[data-md-color-primary] > code { display: block; color: var(--md-primary-bg-color); background-color: var(--md-primary-fg-color); } red pink purple deep purple indigo blue light blue cyan teal green light green lime yellow amber orange deep orange brown grey blue grey black white var buttons = document.querySelectorAll(\"button[data-md-color-primary]\") buttons.forEach(function(button) { var attr = \"data-md-color-primary\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) }) Accent color \u00b6 Default: indigo Click on a color name to change the accent color of the theme: .md-typeset button[data-md-color-accent] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-accent]:hover { opacity: 0.75; } .md-typeset button[data-md-color-accent] > code { display: block; color: var(--md-accent-fg-color); } red pink purple deep purple indigo blue light blue cyan teal green light green lime yellow amber orange deep orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\") buttons.forEach(function(button) { var attr = \"data-md-color-accent\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) }) Fonts \u00b6 Default: Roboto and Roboto Mono The Roboto font family is the default font included with the theme, specifically the regular sans-serif type for text and the monospaced type for code. Both fonts are loaded from Google Fonts and can be changed to any valid webfont, like for example the Ubuntu font family : theme : font : text : Ubuntu code : Ubuntu Mono The text font will be loaded in weights 400 and 700 , the monospaced font in regular weight. If you want to load fonts from other destinations or don't want to use Google Fonts for data privacy reasons, just set font to false : theme : font : false Icons \u00b6 Default: material/library and fontawesome/brands/git-alt Material for MkDocs uses icons in several places. Currently, the following icons can be changed from mkdocs.yml : the logo icon, the repository icon and the social link icons . While the social link icons are tied to the respective entries, the other icons can be changed by referencing a valid path (without the trailing .svg ) relative to the .icons folder which comes with the theme: theme : icon : logo : material/library repo : fontawesome/brands/git-alt All icons are directly inlined as *.svg files, so no further requests will be made. Icon sets which are bundled with Material for MkDocs: Material Design icons ( material ): 5.1k icons FontAwesome icons ( fontawesome ): 1.6k icons GitHub's Octicons ( octicons ): 200 icons You can use all those icons directly from Markdown ! Logo \u00b6 Default: icon set through theme.icon.logo If you want to replace the icon in the header (screen) and drawer (mobile) with your brand's logo, you can place an image file in your docs folder and use the following option in mkdocs.yml : theme : logo : images/logo.svg Ideally, the image should be a square with a minimum resolution of 96x96, leave some room towards the edges and be composed of high contrast areas on a transparent ground, as it will be placed on the colored header and drawer. Favicon \u00b6 Default: assets/images/favicon.png The default favicon can be changed with: theme : favicon : images/favicon.png Extras \u00b6 Adding a source repository \u00b6 To include a link to the repository of your project within your documentation, set the following variables via your project's mkdocs.yml : repo_name : squidfunk/mkdocs-material repo_url : https://github.com/squidfunk/mkdocs-material The name of the repository will be rendered next to the search bar on big screens and as part of the main navigation drawer on smaller screen sizes. Additionally, for GitHub and GitLab, the number of stars and forks is shown. Note that the repository icon can be explicitly set through theme.icon.repo . Why is there an edit button at the top of every article? If the repo_url is set to a GitHub or BitBucket repository, and the repo_name is set to GitHub or BitBucket (implied by default), an edit button will appear at the top of every article. This is the automatic behavior that MkDocs implements. See the MkDocs documentation on more guidance regarding the edit_uri attribute, which defines whether the edit button is shown or not. Adding social links \u00b6 Social accounts can be linked in the footer of the documentation using the icons which are bundled with the theme. Note that each icon must point to a valid path (without the trailing .svg ) relative to the .icons folder which comes with the theme: extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/squidfunk - icon : fontawesome/brands/twitter link : https://twitter.com/squidfunk - icon : fontawesome/brands/linkedin link : https://linkedin.com/in/squidfunk By default, the link title will be set to the domain name, e.g. github.com . If you want to set a discernable name, e.g., to improve your Lighthouse score, you can set the name attribute on each social link. Adding a Web App Manifest \u00b6 A Web App Manifest is a simple JSON file that tells the browser about your web application and how it should behave when installed on the user's mobile device or desktop. You can specify such a manifest in mkdocs.yml : extra : manifest : manifest.webmanifest Integrations \u00b6 Google Analytics \u00b6 MkDocs makes it easy to integrate site tracking with Google Analytics. To enable tracking, which is disabled by default, you must add your tracking identifier to mkdocs.yml : google_analytics : - UA-XXXXXXXX-X - auto Besides basic page views, site search can also be tracked to better understand how people use your documentation and what they expect to find. To enable search tracking: Go to your Google Analytics admin settings Select the property for the respective tracking code Go to the view settings tab. Scroll down and enable site search settings Set the query parameter to q . Disqus \u00b6 Material for MkDocs is integrated with Disqus , so if you want to add a comments section to your documentation set the shortname of your Disqus project in mkdocs.yml : extra : disqus : your-shortname The comments section is inserted on every page, except the index page . The necessary JavaScript is automatically included. Requirements Note that site_url must be set in mkdocs.yml for the Disqus integration to load properly. Disqus can also be enabled or disabled for specific pages using Metadata . Extensions \u00b6 Markdown comes with several very useful extensions, the following of which are not enabled by default but highly recommended, so enabling them should definitely be a good idea: markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true See the following list of extensions supported by Material for MkDocs including some more information on configuration and usage: Admonition Codehilite Footnotes Metadata Permalinks PyMdown Extensions Plugins \u00b6 MkDocs' plugin architecture makes it possible to add pre- or post-processing steps that sit between the theme and your documentation. For more information, see the following list of plugins tested and supported by Material for MkDocs including more information regarding installation and usage: Search (enabled by default) Minification Revision date Awesome pages For further reference, the MkDocs wiki contains a list of all available plugins .","title":"Getting started"},{"location":"API%20Documentation/about/#getting-started","text":"","title":"Getting started"},{"location":"API%20Documentation/about/#installation","text":"While there are several ways of installing Material for MkDocs, the recommended methods are either by using pip \u2013 the Python package manager \u2013 or by pulling the official Docker image .","title":"Installation"},{"location":"API%20Documentation/about/#with-pip-recommended","text":"Material for MkDocs can be installed with pip : pip install mkdocs-material Note that this will automatically install compatible versions of MkDocs , Markdown , Pygments and PyMdown Extensions . Material for MkDocs always strives to support the latest versions, so there's no need to install those packages separately. Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a tutorial on virtual environments for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Installing in user space (recommended): Provide the --user flag to the install command and pip will install the package in a user-site location. This is the recommended way. Switching to a homebrewed Python : Upgrade your Python installation to a self-contained solution by installing Python with Homebrew. This should eliminate a lot of problems you could be having with pip . Error: unrecognized theme 'material' If you run into this error, the most common reason is that you installed MkDocs through some package manager (e.g. Homebrew or apt-get ) and Material for MkDocs through pip , so both packages end up in different locations. MkDocs only checks its install location for themes.","title":"with pip recommended"},{"location":"API%20Documentation/about/#with-docker-recommended","text":"The official Docker image is a great way to get up and running in a few minutes, as it comes with all dependencies pre-installed. Pull the image for the latest version with: docker pull squidfunk/mkdocs-material The mkdocs executable is provided as an entry point and serve is the default command. Start the development server in your project root \u2013 the folder where mkdocs.yml resides \u2014 with: Unix docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material Windows docker run --rm -it -p 8000:8000 -v \"%cd%\":/docs squidfunk/mkdocs-material","title":"with docker recommended"},{"location":"API%20Documentation/about/#with-git","text":"Material for MkDocs can be directly used from GitHub by cloning the repository into a subfolder of your project root which might be useful if you want to use the very latest version: git clone https://github.com/squidfunk/mkdocs-material.git The theme will reside in the folder mkdocs-material/material .","title":"with git"},{"location":"API%20Documentation/about/#configuration","text":"Depending on your installation method, you can now add the following lines to mkdocs.yml in your project root. If you installed Material for MkDocs using a package manager, add: theme : name : material If you cloned Material for MkDocs from GitHub add: theme : name : null custom_dir : mkdocs-material/material MkDocs includes a development server, so you can preview your changes as you write your documentation. The development server can be started with the following command: mkdocs serve Point your browser to http://localhost:8000 and your documentation should greet you in a new look. If you're starting from scratch, the following configuration can be used as a starting point: Example configuration This is an excerpt from the mkdocs.yml used to render these pages: # Project information site_name : Material for MkDocs site_description : A Material Design theme for MkDocs site_author : Martin Donath site_url : https://squidfunk.github.io/mkdocs-material/ # Repository repo_name : squidfunk/mkdocs-material repo_url : https://github.com/squidfunk/mkdocs-material # Copyright copyright : Copyright &copy; 2016 - 2020 Martin Donath # Configuration theme : name : material language : en palette : primary : indigo accent : indigo font : text : Roboto code : Roboto Mono # Extras extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/squidfunk - icon : fontawesome/brands/twitter link : https://twitter.com/squidfunk - icon : fontawesome/brands/linkedin link : https://linkedin.com/in/squidfunk # Google Analytics google_analytics : - UA-XXXXXXXX-X - auto # Extensions markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true","title":"Configuration"},{"location":"API%20Documentation/about/#feature-flags","text":"These optional features are hidden behind flags and can be explicitly enabled in mkdocs.yml .","title":"Feature flags"},{"location":"API%20Documentation/about/#instant-loading","text":"The (still experimental) instant loading feature will intercept clicks on all internal links and dispatch them directly via XHR without a full page reload. It can be enabled from mkdocs.yml with: theme : features : - instant The resulting page is parsed and injected and all event handlers and components are automatically rebound. This means that Material for MkDocs behaves like a Single Page Application , which is especially useful for large documentation sites that come with a huge search index, as the search index will now remain intact in-between document switches.","title":"Instant loading"},{"location":"API%20Documentation/about/#tabs","text":"The tabs feature will render top-level subsections in another navigational layer below the header on big screens (but leave them untouched on mobile). It can be enabled from mkdocs.yml with: theme : features : - tabs Note that all top-level pages (i.e. all top-level entries that directly refer to an *.md file) defined inside the nav entry of mkdocs.yml will be grouped under the first tab which will receive the title of the first page. This means that there will effectively be no collapsible subsections for the first tab, as each subsection is rendered as another tab. If you want more fine-grained control, i.e., collapsible subsections for the first tab, you can move all top-level pages into a subsection , so that the top-level is entirely made up of subsections. Note that tabs are only shown for larger screens, so make sure that navigation is plausible on mobile devices. As an example, see the mkdocs.yml used to render these pages.","title":"Tabs"},{"location":"API%20Documentation/about/#language","text":"Default: en Material for MkDocs supports internationalization (i18n) and provides translations for all template variables and labels. You can set the language from mkdocs.yml with: theme : language : en The following language codes are supported: .md-language-list { -webkit-columns: 2; -moz-columns: 2; columns: 2; } .md-language-list li { -webkit-column-break-inside: avoid; page-break-inside: avoid; break-inside: avoid; } af / Afrikaans ar / Arabic bn / Bengali (Bangla) ca / Catalan cs / Czech da / Danish de / German en / English es / Spanish et / Estonian fa / Persian (Farsi) fi / Finnish fr / French gl / Galician gr / Greek he / Hebrew hi / Hindi hr / Croatian hu / Hungarian id / Indonesian it / Italian ja / Japanese kr / Korean my / Burmese nl / Dutch nn / Norwegian (Nynorsk) no / Norwegian pl / Polish pt / Portuguese ro / Romanian ru / Russian sh / Serbo-Croatian si / Slovenian sk / Slovak sr / Serbian sv / Swedish th / Thai tr / Turkish uk / Ukrainian vi / Vietnamese zh / Chinese (Simplified) zh-Hant / Chinese (Traditional) zh-TW / Chinese (Taiwanese) Add language While many languages are read ltr (left-to-right), Material for MkDocs also supports rtl (right-to-left) directionality which is inferred from the selected language, but can also be set with: theme : direction : rtl","title":"Language"},{"location":"API%20Documentation/about/#color-scheme","text":"Default: default Material for MkDocs supports two color schemes: a light mode, which is just called default , and a dark mode, which is called slate . The color scheme can be set from mkdocs.yml : theme : palette : scheme : slate Click on a color name to change the color scheme of the theme: .md-typeset button[data-md-color-scheme] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-scheme]:hover { opacity: 0.75; } .md-typeset button[data-md-color-scheme] > code { display: block; color: var(--md-primary-bg-color); background-color: var(--md-primary-fg-color); } default slate var buttons = document.querySelectorAll(\"button[data-md-color-scheme]\") buttons.forEach(function(button) { var attr = \"data-md-color-scheme\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) }) The color scheme can also be set based on user preference , which makes use of the prefers-color-scheme media query. This can be done by adding the following to mkdocs.yml : theme : palette : scheme : preference","title":"Color scheme"},{"location":"API%20Documentation/about/#color-palette","text":"The Material Design color palette comes with 20 hues, all of which are included with Material for MkDocs. Primary and accent colors can be set from the project root's mkdocs.yml : theme : palette : primary : indigo accent : indigo If the colors are set with these configuration options, an additional CSS file that includes the hues of the color palette is automatically included and linked from the template. Custom colors with CSS variables Material for MkDocs defines all colors as CSS variables. If you want to customize the colors beyond the palette (e.g. to use your brand's colors), you can add an additional stylesheet and override the defaults: : root { /* Default color shades */ -- md-default-fg-color : ... ; -- md-default-fg-color--light : ... ; -- md-default-fg-color--lighter : ... ; -- md-default-fg-color--lightest : ... ; -- md-default-bg-color : ... ; -- md-default-bg-color--light : ... ; -- md-default-bg-color--lighter : ... ; -- md-default-bg-color--lightest : ... ; /* Primary color shades */ -- md-primary-fg-color : ... ; -- md-primary-fg-color--light : ... ; -- md-primary-fg-color--dark : ... ; -- md-primary-bg-color : ... ; -- md-primary-bg-color--light : ... ; /* Accent color shades */ -- md-accent-fg-color : ... ; -- md-accent-fg-color--transparent : ... ; -- md-accent-bg-color : ... ; -- md-accent-bg-color--light : ... ; } : root > * { /* Code block color shades */ -- md-code-bg-color : ... ; -- md-code-fg-color : ... ; }","title":"Color palette"},{"location":"API%20Documentation/about/#primary-color","text":"Default: indigo Click on a color name to change the primary color of the theme: .md-typeset button[data-md-color-primary] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-primary]:hover { opacity: 0.75; } .md-typeset button[data-md-color-primary] > code { display: block; color: var(--md-primary-bg-color); background-color: var(--md-primary-fg-color); } red pink purple deep purple indigo blue light blue cyan teal green light green lime yellow amber orange deep orange brown grey blue grey black white var buttons = document.querySelectorAll(\"button[data-md-color-primary]\") buttons.forEach(function(button) { var attr = \"data-md-color-primary\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) })","title":"Primary color"},{"location":"API%20Documentation/about/#accent-color","text":"Default: indigo Click on a color name to change the accent color of the theme: .md-typeset button[data-md-color-accent] { cursor: pointer; transition: opacity 250ms; } .md-typeset button[data-md-color-accent]:hover { opacity: 0.75; } .md-typeset button[data-md-color-accent] > code { display: block; color: var(--md-accent-fg-color); } red pink purple deep purple indigo blue light blue cyan teal green light green lime yellow amber orange deep orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\") buttons.forEach(function(button) { var attr = \"data-md-color-accent\" button.addEventListener(\"click\", function() { document.body.setAttribute(attr, this.getAttribute(attr)) }) })","title":"Accent color"},{"location":"API%20Documentation/about/#fonts","text":"Default: Roboto and Roboto Mono The Roboto font family is the default font included with the theme, specifically the regular sans-serif type for text and the monospaced type for code. Both fonts are loaded from Google Fonts and can be changed to any valid webfont, like for example the Ubuntu font family : theme : font : text : Ubuntu code : Ubuntu Mono The text font will be loaded in weights 400 and 700 , the monospaced font in regular weight. If you want to load fonts from other destinations or don't want to use Google Fonts for data privacy reasons, just set font to false : theme : font : false","title":"Fonts"},{"location":"API%20Documentation/about/#icons","text":"Default: material/library and fontawesome/brands/git-alt Material for MkDocs uses icons in several places. Currently, the following icons can be changed from mkdocs.yml : the logo icon, the repository icon and the social link icons . While the social link icons are tied to the respective entries, the other icons can be changed by referencing a valid path (without the trailing .svg ) relative to the .icons folder which comes with the theme: theme : icon : logo : material/library repo : fontawesome/brands/git-alt All icons are directly inlined as *.svg files, so no further requests will be made. Icon sets which are bundled with Material for MkDocs: Material Design icons ( material ): 5.1k icons FontAwesome icons ( fontawesome ): 1.6k icons GitHub's Octicons ( octicons ): 200 icons You can use all those icons directly from Markdown !","title":"Icons"},{"location":"API%20Documentation/about/#logo","text":"Default: icon set through theme.icon.logo If you want to replace the icon in the header (screen) and drawer (mobile) with your brand's logo, you can place an image file in your docs folder and use the following option in mkdocs.yml : theme : logo : images/logo.svg Ideally, the image should be a square with a minimum resolution of 96x96, leave some room towards the edges and be composed of high contrast areas on a transparent ground, as it will be placed on the colored header and drawer.","title":"Logo"},{"location":"API%20Documentation/about/#favicon","text":"Default: assets/images/favicon.png The default favicon can be changed with: theme : favicon : images/favicon.png","title":"Favicon"},{"location":"API%20Documentation/about/#extras","text":"","title":"Extras"},{"location":"API%20Documentation/about/#adding-a-source-repository","text":"To include a link to the repository of your project within your documentation, set the following variables via your project's mkdocs.yml : repo_name : squidfunk/mkdocs-material repo_url : https://github.com/squidfunk/mkdocs-material The name of the repository will be rendered next to the search bar on big screens and as part of the main navigation drawer on smaller screen sizes. Additionally, for GitHub and GitLab, the number of stars and forks is shown. Note that the repository icon can be explicitly set through theme.icon.repo . Why is there an edit button at the top of every article? If the repo_url is set to a GitHub or BitBucket repository, and the repo_name is set to GitHub or BitBucket (implied by default), an edit button will appear at the top of every article. This is the automatic behavior that MkDocs implements. See the MkDocs documentation on more guidance regarding the edit_uri attribute, which defines whether the edit button is shown or not.","title":"Adding a source repository"},{"location":"API%20Documentation/about/#adding-social-links","text":"Social accounts can be linked in the footer of the documentation using the icons which are bundled with the theme. Note that each icon must point to a valid path (without the trailing .svg ) relative to the .icons folder which comes with the theme: extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/squidfunk - icon : fontawesome/brands/twitter link : https://twitter.com/squidfunk - icon : fontawesome/brands/linkedin link : https://linkedin.com/in/squidfunk By default, the link title will be set to the domain name, e.g. github.com . If you want to set a discernable name, e.g., to improve your Lighthouse score, you can set the name attribute on each social link.","title":"Adding social links"},{"location":"API%20Documentation/about/#adding-a-web-app-manifest","text":"A Web App Manifest is a simple JSON file that tells the browser about your web application and how it should behave when installed on the user's mobile device or desktop. You can specify such a manifest in mkdocs.yml : extra : manifest : manifest.webmanifest","title":"Adding a Web App Manifest"},{"location":"API%20Documentation/about/#integrations","text":"","title":"Integrations"},{"location":"API%20Documentation/about/#google-analytics","text":"MkDocs makes it easy to integrate site tracking with Google Analytics. To enable tracking, which is disabled by default, you must add your tracking identifier to mkdocs.yml : google_analytics : - UA-XXXXXXXX-X - auto Besides basic page views, site search can also be tracked to better understand how people use your documentation and what they expect to find. To enable search tracking: Go to your Google Analytics admin settings Select the property for the respective tracking code Go to the view settings tab. Scroll down and enable site search settings Set the query parameter to q .","title":"Google Analytics"},{"location":"API%20Documentation/about/#disqus","text":"Material for MkDocs is integrated with Disqus , so if you want to add a comments section to your documentation set the shortname of your Disqus project in mkdocs.yml : extra : disqus : your-shortname The comments section is inserted on every page, except the index page . The necessary JavaScript is automatically included. Requirements Note that site_url must be set in mkdocs.yml for the Disqus integration to load properly. Disqus can also be enabled or disabled for specific pages using Metadata .","title":"Disqus"},{"location":"API%20Documentation/about/#extensions","text":"Markdown comes with several very useful extensions, the following of which are not enabled by default but highly recommended, so enabling them should definitely be a good idea: markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true See the following list of extensions supported by Material for MkDocs including some more information on configuration and usage: Admonition Codehilite Footnotes Metadata Permalinks PyMdown Extensions","title":"Extensions"},{"location":"API%20Documentation/about/#plugins","text":"MkDocs' plugin architecture makes it possible to add pre- or post-processing steps that sit between the theme and your documentation. For more information, see the following list of plugins tested and supported by Material for MkDocs including more information regarding installation and usage: Search (enabled by default) Minification Revision date Awesome pages For further reference, the MkDocs wiki contains a list of all available plugins .","title":"Plugins"},{"location":"Concepts/actions/","text":"Actions \u00b6 Overview \u00b6 Actions are functions, their job is to perform a task. The key difference between a normal function and an Action is that once an action is completed it returns a list of mutations. Then these mutations are sent to their respective stores which may or may not cause change in the state. Action do the How part of obtaining the data, it can be from a database, an api call, a file or anything. Once the data is obtained they are converted to mutations. Therefore, in general we call Action causes changes but it's important to understand that Actions play a bigger role than just mutating state. ActionRef \u00b6 ActionRef or ActionReference is where you define your actions but do not create it. It's only a refernce to your action. final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); setRef above is refernce we can obtain it anywhere. Generally it's better to define all your action refernce in a class as static values. Whenever we want to create an Action we will call the action reference //CounterParam is the required payload here final action = setRef ( CounterParam ()); But the actions still hasn't been executed, the Dispatcher knows that we have created an action but we haven't requested the dispatcher to execute it. If we want to execute our action we will call the run() action . run ()","title":"Actions"},{"location":"Concepts/actions/#actions","text":"","title":"Actions"},{"location":"Concepts/actions/#overview","text":"Actions are functions, their job is to perform a task. The key difference between a normal function and an Action is that once an action is completed it returns a list of mutations. Then these mutations are sent to their respective stores which may or may not cause change in the state. Action do the How part of obtaining the data, it can be from a database, an api call, a file or anything. Once the data is obtained they are converted to mutations. Therefore, in general we call Action causes changes but it's important to understand that Actions play a bigger role than just mutating state.","title":"Overview"},{"location":"Concepts/actions/#actionref","text":"ActionRef or ActionReference is where you define your actions but do not create it. It's only a refernce to your action. final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); setRef above is refernce we can obtain it anywhere. Generally it's better to define all your action refernce in a class as static values. Whenever we want to create an Action we will call the action reference //CounterParam is the required payload here final action = setRef ( CounterParam ()); But the actions still hasn't been executed, the Dispatcher knows that we have created an action but we haven't requested the dispatcher to execute it. If we want to execute our action we will call the run() action . run ()","title":"ActionRef"},{"location":"Concepts/dispatcher/","text":"Dispatcher \u00b6 Overview \u00b6 Dispatcher is a control unit of your application. It provides a mechanism to execute actions and dispatch mutations to the stores. Throughout the application you have a single Dispatcher, it becomes very useful in managing dependencies among actions. For example waiting for a set of actions to complete before executing an action. Dispatcher also provides onError and onDone callbacks on every action. For Flux/Redux developers In Nano the Dispatcher doesn't keep the track of stores, you will have to provide them with your actions whereas in Redux/Flux every store registers itself with the dispatcher, which allows your to acess the Store directly from the disptacher.","title":"Dispatcher"},{"location":"Concepts/dispatcher/#dispatcher","text":"","title":"Dispatcher"},{"location":"Concepts/dispatcher/#overview","text":"Dispatcher is a control unit of your application. It provides a mechanism to execute actions and dispatch mutations to the stores. Throughout the application you have a single Dispatcher, it becomes very useful in managing dependencies among actions. For example waiting for a set of actions to complete before executing an action. Dispatcher also provides onError and onDone callbacks on every action. For Flux/Redux developers In Nano the Dispatcher doesn't keep the track of stores, you will have to provide them with your actions whereas in Redux/Flux every store registers itself with the dispatcher, which allows your to acess the Store directly from the disptacher.","title":"Overview"},{"location":"Concepts/store/","text":"Store \u00b6 Overview \u00b6 Stores are somewhat similar to Redux Store or Bloc. They contain the state of the application and the logic to mutate the state. A store can hold any type of value, a single record or a collection. The major difference in Nano is that the application state is divided into multiple stores depending upon features or domain, this allows us to make our code modular. Stores also only contain the business logic related only to its state mutation and computated value, a store only cares about the end input it doesn't care about How the input values are obtained. Stores are essentially a part of Presentation Layer Stores are a communication link between your Data Layer and Views. A store receives the mutations and it renders a new state accordingls. It only cares about the data required not How you obtained the data. Mutation \u00b6 Mutation are events that are received by the Store and cause mutation of the state. Every store is registered with specific mutations, only those mutation event can cause change of state. Mutations are so received sequentially by the store. At a time only one mutation are processed, rest of the mutations are queued. Mutations are queued by the order they arrive to the store. Reducer \u00b6 Reducer are pure functions that contains logic of mutating the state. Unlike Redux reducer is a part of the Store, every store has it's own reducer. Once a mutation is received it's forwarded to the reducer, where you identify the mutation type and change the state accordingly","title":"Store"},{"location":"Concepts/store/#store","text":"","title":"Store"},{"location":"Concepts/store/#overview","text":"Stores are somewhat similar to Redux Store or Bloc. They contain the state of the application and the logic to mutate the state. A store can hold any type of value, a single record or a collection. The major difference in Nano is that the application state is divided into multiple stores depending upon features or domain, this allows us to make our code modular. Stores also only contain the business logic related only to its state mutation and computated value, a store only cares about the end input it doesn't care about How the input values are obtained. Stores are essentially a part of Presentation Layer Stores are a communication link between your Data Layer and Views. A store receives the mutations and it renders a new state accordingls. It only cares about the data required not How you obtained the data.","title":"Overview"},{"location":"Concepts/store/#mutation","text":"Mutation are events that are received by the Store and cause mutation of the state. Every store is registered with specific mutations, only those mutation event can cause change of state. Mutations are so received sequentially by the store. At a time only one mutation are processed, rest of the mutations are queued. Mutations are queued by the order they arrive to the store.","title":"Mutation"},{"location":"Concepts/store/#reducer","text":"Reducer are pure functions that contains logic of mutating the state. Unlike Redux reducer is a part of the Store, every store has it's own reducer. Once a mutation is received it's forwarded to the reducer, where you identify the mutation type and change the state accordingly","title":"Reducer"}]}